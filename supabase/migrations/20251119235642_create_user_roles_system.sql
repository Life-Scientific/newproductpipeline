-- ============================================================================
-- Migration: Create User Roles and Permissions System
-- Description: Creates a simple role-based access control (RBAC) system
--              with roles (viewer, editor) and user role assignments
-- ============================================================================

-- Create role enum
CREATE TYPE public.app_role AS ENUM ('viewer', 'editor');

-- User roles table - links auth.users to app roles
CREATE TABLE public.user_roles (
  id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  user_id uuid REFERENCES auth.users(id) ON DELETE CASCADE NOT NULL,
  role public.app_role NOT NULL DEFAULT 'viewer',
  created_at timestamptz DEFAULT now(),
  updated_at timestamptz DEFAULT now(),
  UNIQUE(user_id)
);

COMMENT ON TABLE public.user_roles IS 'Application roles for each user. Links Supabase auth.users to app roles.';
COMMENT ON COLUMN public.user_roles.role IS 'The role assigned to the user (viewer or editor)';

-- Index for faster lookups
CREATE INDEX idx_user_roles_user_id ON public.user_roles(user_id);
CREATE INDEX idx_user_roles_role ON public.user_roles(role);

-- Function to update updated_at timestamp
CREATE OR REPLACE FUNCTION update_user_roles_updated_at()
RETURNS TRIGGER AS $$
BEGIN
  NEW.updated_at = now();
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Trigger for updated_at
CREATE TRIGGER trg_user_roles_updated_at
  BEFORE UPDATE ON public.user_roles
  FOR EACH ROW
  EXECUTE FUNCTION update_user_roles_updated_at();

-- Function to get user role (for use in RLS policies)
CREATE OR REPLACE FUNCTION public.get_user_role()
RETURNS public.app_role
LANGUAGE plpgsql
STABLE
SECURITY DEFINER
SET search_path = ''
AS $$
DECLARE
  user_role public.app_role;
BEGIN
  SELECT role INTO user_role
  FROM public.user_roles
  WHERE user_id = auth.uid();
  
  RETURN COALESCE(user_role, 'viewer'::public.app_role);
END;
$$;

COMMENT ON FUNCTION public.get_user_role() IS 'Returns the app role for the current authenticated user. Returns ''viewer'' by default if no role is assigned.';

-- Function to check if user is editor (for use in RLS policies)
CREATE OR REPLACE FUNCTION public.is_editor()
RETURNS boolean
LANGUAGE plpgsql
STABLE
SECURITY DEFINER
SET search_path = ''
AS $$
BEGIN
  RETURN public.get_user_role() = 'editor'::public.app_role;
END;
$$;

COMMENT ON FUNCTION public.is_editor() IS 'Returns true if the current authenticated user has the editor role.';

-- Enable RLS on user_roles table
ALTER TABLE public.user_roles ENABLE ROW LEVEL SECURITY;

-- RLS Policy: Users can view their own role
CREATE POLICY "Users can view their own role"
ON public.user_roles
FOR SELECT
TO authenticated
USING (user_id = auth.uid());

-- RLS Policy: Editors can view all roles
CREATE POLICY "Editors can view all roles"
ON public.user_roles
FOR SELECT
TO authenticated
USING ((SELECT public.is_editor()));

-- RLS Policy: Editors can insert roles
CREATE POLICY "Editors can insert roles"
ON public.user_roles
FOR INSERT
TO authenticated
WITH CHECK ((SELECT public.is_editor()));

-- RLS Policy: Editors can update roles
CREATE POLICY "Editors can update roles"
ON public.user_roles
FOR UPDATE
TO authenticated
USING ((SELECT public.is_editor()))
WITH CHECK ((SELECT public.is_editor()));

-- RLS Policy: Editors can delete roles
CREATE POLICY "Editors can delete roles"
ON public.user_roles
FOR DELETE
TO authenticated
USING ((SELECT public.is_editor()));

-- Grant necessary permissions
GRANT USAGE ON SCHEMA public TO authenticated, anon;
GRANT SELECT, INSERT, UPDATE, DELETE ON public.user_roles TO authenticated;
GRANT USAGE ON TYPE public.app_role TO authenticated;

-- Note: We can't create a view that directly queries auth.users with RLS
-- Instead, we use the get_all_users_with_roles() function below

-- Function to automatically assign 'viewer' role to new users
CREATE OR REPLACE FUNCTION public.handle_new_user()
RETURNS TRIGGER
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = ''
AS $$
BEGIN
  INSERT INTO public.user_roles (user_id, role)
  VALUES (NEW.id, 'viewer'::public.app_role)
  ON CONFLICT (user_id) DO NOTHING;
  RETURN NEW;
END;
$$;

COMMENT ON FUNCTION public.handle_new_user() IS 'Automatically assigns the default ''viewer'' role to new users when they sign up.';

-- Trigger to assign default role on user creation
CREATE TRIGGER on_auth_user_created
  AFTER INSERT ON auth.users
  FOR EACH ROW
  EXECUTE FUNCTION public.handle_new_user();

-- Grant execute permission to supabase_auth_admin for the trigger function
GRANT EXECUTE ON FUNCTION public.handle_new_user() TO supabase_auth_admin;

-- Function to get all users with their roles (editor only, security definer)
-- This function can access auth.users because it runs as the creator (postgres role)
CREATE OR REPLACE FUNCTION public.get_all_users_with_roles()
RETURNS TABLE (
  id uuid,
  email text,
  user_created_at timestamptz,
  last_sign_in_at timestamptz,
  email_confirmed_at timestamptz,
  role public.app_role,
  role_assigned_at timestamptz,
  role_updated_at timestamptz
)
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = ''
AS $$
BEGIN
  -- Check if current user is editor
  IF NOT (SELECT public.is_editor()) THEN
    RAISE EXCEPTION 'Unauthorized: Editor access required';
  END IF;

  RETURN QUERY
  SELECT 
    u.id,
    u.email::text,
    u.created_at,
    u.last_sign_in_at,
    u.email_confirmed_at,
    COALESCE(ur.role, 'viewer'::public.app_role) as role,
    ur.created_at as role_assigned_at,
    ur.updated_at as role_updated_at
  FROM auth.users u
  LEFT JOIN public.user_roles ur ON u.id = ur.user_id
  ORDER BY u.created_at DESC;
END;
$$;

COMMENT ON FUNCTION public.get_all_users_with_roles() IS 'Returns all users with their roles. Editor only. Uses security definer to access auth.users.';

-- Grant execute to authenticated users (RLS check happens inside function)
GRANT EXECUTE ON FUNCTION public.get_all_users_with_roles() TO authenticated;

-- ============================================================================
-- Auth Hook: Add user role to JWT tokens
-- ============================================================================
-- This hook adds the user's role to the JWT access token so it's available
-- in the session without needing to query the database each time.
CREATE OR REPLACE FUNCTION public.custom_access_token_hook(event jsonb)
RETURNS jsonb
LANGUAGE plpgsql
STABLE
SECURITY DEFINER
SET search_path = ''
AS $$
DECLARE
  claims jsonb;
  user_role public.app_role;
BEGIN
  -- Fetch the user role from the user_roles table
  SELECT role INTO user_role 
  FROM public.user_roles 
  WHERE user_id = (event->>'user_id')::uuid;

  claims := event->'claims';

  -- Set the user_role claim in the JWT
  IF user_role IS NOT NULL THEN
    claims := jsonb_set(claims, '{user_role}', to_jsonb(user_role));
  ELSE
    -- Default to viewer if no role is assigned
    claims := jsonb_set(claims, '{user_role}', '"viewer"');
  END IF;

  -- Update the 'claims' object in the original event
  event := jsonb_set(event, '{claims}', claims);

  -- Return the modified event
  RETURN event;
END;
$$;

COMMENT ON FUNCTION public.custom_access_token_hook(event jsonb) IS 'Auth hook that adds user_role claim to JWT tokens. Must be enabled in Supabase Dashboard > Authentication > Hooks.';

-- Grant necessary permissions for the auth hook
GRANT USAGE ON SCHEMA public TO supabase_auth_admin;
GRANT EXECUTE ON FUNCTION public.custom_access_token_hook(jsonb) TO supabase_auth_admin;
REVOKE EXECUTE ON FUNCTION public.custom_access_token_hook(jsonb) FROM authenticated, anon, public;
GRANT SELECT ON TABLE public.user_roles TO supabase_auth_admin;

-- ============================================================================
-- IMPORTANT: Assigning the first editor
-- ============================================================================
-- After running this migration, assign jack@fieldzero.io as editor:
--
--   INSERT INTO public.user_roles (user_id, role)
--   SELECT id, 'editor'::public.app_role
--   FROM auth.users
--   WHERE email = 'jack@fieldzero.io'
--   ON CONFLICT (user_id) DO UPDATE SET role = 'editor';
--
-- Then enable the auth hook in Supabase Dashboard:
--   Authentication > Hooks (Beta) > Custom Access Token Hook
--   Select: public.custom_access_token_hook
-- ============================================================================

